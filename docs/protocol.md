Update format
=============
Each update of database has HTTP-like format. Updates consist of key-value
pairs in format:
```
Field: value
```
Each field is alphanumeric, case sensitive string (a-z A-Z 0-9) with dashes
allowed. Also value should be an alphanumeric string, however here all
characters are allowed. If kind of field in update might contain new lines
or non-ascii characters, then base64 encoding shoud be applied to value
of certain field. It is not possible to use optional base64 encoding. This
should be implemented on all database nodes.

Multiple fields in one update are separated by new line character (\n).
There is no option to use \n\r or \r\n combination known from HTTP. Also
the separator of field and value is always colon and space (: ). The only
colon might be treated as the part of field, however this sign is not allowed
in field names.

Order of fields in update is significant. All above rules should be respected
on all database nodes to provide proper signature verification process.

Example header:
```
Caller: af98q0faq34mad0
Action: SET
Field: name
Value: ==q34u08p
```

Headers
=======

Signatures, verification and ordering
=====================================
Each object in database has its own, asymmetric key pair. This makes possible
to sign each update of database state by such private key and verify by public
key, known by all other nodes. Each object has field authorized_keys, which is
a list with public keys, authorized to make updates of all fields in object
and its all sub-objects. All subobjects could have its own authorized_keys
too.

Signing the update
------------------
Due to database updates could be modified by database nodes (new fields could
be appended at the end), order of fields is very important. Signature of
update is generated by saving update in form of string. Such string is signed
by owner's private key and two new headers are appended:
* Signature - base64-encoded signature
* Signature-Method - method of signing
Above headers are appended to the end of update's headers.

Signed update should have trailing new line, at the end and no empty lines
inside. Also all mentioned in first chapter format specs should be respected
to create proper signature.

Verifing update
---------------
To verify signed update, remove Signature and Signature-Method headers.
Remove also all headers after Signature or Signature-Method. In some cases
new headers could be appended after signing update, to store information about
network path or timestamp, when update was received by other nodes. Such
information should have its own Signature and Signature-Method headers, for
whole, extended update:
```
Caller: wpare0q038fo
Action: NOOP
Previous: idofpreviousupdate
Previous-Hash: abcdefgh...
...
Signature: fq0w39rafojf...
Signature-Method: GPG
Caller: 0q34edk
Received: 01-Jul-2017 22:43:58
Signature: d03g9wr...
Signature-Method: GPG
```
Above example has two signatures. First one verifies the original database
update, made by fq0w39rafojf... object. Second signature verifies timestamp
appended by d03g9wr... object.

Update arrangement
----------------
To kees updates in proper order, each update has the Previous and
Previous-Hash fields. This makes possible to verify if previous update was not
malformed or manipulated, hash of previous update is attached to headers.
This, together with ID of previous update makes a chain of updates. In some
cases (i.e. split brain) it is possible to make a tree, after setting two
different updates after another.

In that case, whole update arrangement becomes a tree. In some, more
sophisticated cases, some database nodes could verify (after joining split
brain) order and confirm arrangement of updates on two branches together:
```
Caller: wpare0q038fo
Action: NOOP
Previous: idofpreviousupdate
Previous-Hash: abcdefgh...
...
Signature: fq0w39rafojf...
Signature-Method: GPG
Previous: idofpreviousupdate
Previous-Hash: abcdefgh...
Caller: 0q34edk
Signature: d03g9wr... 
Signature-Method: GPG
```

Caller vs. Object header
========================
Most updates are related to the set/create/delete actions on database fields.
To distinguish differences between an entity that is creating object and
modified object, the both headers are present in each update:
- Caller - id of object, which created update (and its key is used to sign
  update
- Object - id of object, which is modified

Thus, protocol allows to create updates by one object and modify another one.
This approach gives opportunity to create access lists across various objects
and subobjects in database.
